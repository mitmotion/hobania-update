use super::*;
use crate::{
    util::{RandomField, Sampler, LOCALITY},
    Land,
};
use common::{
    generation::EntityInfo,
    terrain::{BlockKind, SpriteKind},
};
use rand::prelude::*;
use std::mem;
use vek::*;

/// Represents house data generated by the `generate()` method
pub struct CliffTower {
    /// Axis aligned bounding region for the house
    bounds: Aabr<i32>,
    /// Approximate altitude of the door tile
    pub(crate) alt: i32,
}

impl CliffTower {
    pub fn generate(
        land: &Land,
        _rng: &mut impl Rng,
        site: &Site,
        door_tile: Vec2<i32>,
        door_dir: Vec2<i32>,
        tile_aabr: Aabr<i32>,
    ) -> Self {
        let bounds = Aabr {
            min: site.tile_wpos(tile_aabr.min),
            max: site.tile_wpos(tile_aabr.max),
        };
        Self {
            bounds,
            alt: land.get_alt_approx(site.tile_center_wpos(door_tile + door_dir)) as i32,
        }
    }
}

impl<F: Filler> Structure<F> for CliffTower {
    fn render<'a>(&self, _site: &Site, _land: Land, painter: &Painter<'a>, filler: &mut FillFn<'a, '_, F>) {
        let base = self.alt + 1;
        let center = self.bounds.center();
        let variant_pos = center.with_z(base);
        let variant = RandomField::new(0).get(variant_pos) as i32 % 10;
        // common superquadric degree for rooms
        let sq_type = 2.5;
        let storeys = 5 + (variant / 2);
        let mut length = 16 + (variant / 2);
        let mut width = 7 * length / 8;
        let mut height = 18 + variant / 2;
        let (mut stair_pos1, mut stair_pos2) = (center - 3, center + 3);
        let mut floor_level = base - 40;
        fn brick_fill<'a>(arena: &'a bumpalo::Bump, range: Range<i32>) -> impl Fn(Vec3<i32>) -> Option<Block> + 'a {
            // Precompute bricks for each height level.
            let start = range.start;
            let bricks = &*arena.alloc_slice_fill_iter(/*(0..x_bounds)*/range.map(|z| {
                match (RandomField::new(0).get(Vec3::new(z, 0, 0))) % 15 {
                    0 => Block::new(BlockKind::Rock, Rgb::new(51, 89, 118)),
                    1 => Block::new(BlockKind::Rock, Rgb::new(57, 96, 126)),
                    2 => Block::new(BlockKind::Rock, Rgb::new(59, 103, 136)),
                    3 => Block::new(BlockKind::Rock, Rgb::new(61, 109, 145)),
                    4 => Block::new(BlockKind::Rock, Rgb::new(42, 66, 87)),
                    5 => Block::new(BlockKind::Rock, Rgb::new(47, 76, 101)),
                    6 => Block::new(BlockKind::Rock, Rgb::new(50, 84, 110)),
                    7 => Block::new(BlockKind::Rock, Rgb::new(52, 85, 112)),
                    8 => Block::new(BlockKind::Rock, Rgb::new(51, 60, 66)),
                    9 => Block::new(BlockKind::Rock, Rgb::new(58, 74, 87)),
                    10 => Block::new(BlockKind::Rock, Rgb::new(53, 104, 111)),
                    11 => Block::new(BlockKind::Rock, Rgb::new(52, 63, 72)),
                    12 => Block::new(BlockKind::Rock, Rgb::new(52, 63, 72)),
                    13 => Block::new(BlockKind::Rock, Rgb::new(74, 128, 168)),
                    _ => Block::new(BlockKind::Rock, Rgb::new(69, 123, 162)),
                }
            }));
            // move |pos| bricks.get((pos.z - start) as usize).copied()
            move |pos| (pos.z - start).try_into().ok().and_then(|z: usize| bricks.get(z).copied())
        }

        let brick_fill = brick_fill(painter.arena, floor_level..floor_level + (storeys + 1) * height);
        /* let brick_fill = &*painter.arena.alloc_with(move || brick_fill); */
        let brick = /*Fill::Sampling*/filler.sampling(&brick_fill);
        let wood = filler.brick(BlockKind::Wood, Rgb::new(106, 83, 51), 12);
        let color = filler.block(Block::air(SpriteKind::CliffDecorBlock));
        let window = filler.block(Block::air(SpriteKind::WindowArabic));
        let window2 = filler.block(Block::air(SpriteKind::WindowArabic).with_ori(2).unwrap());
        for s in 0..storeys {
            let old_x_offset = RandomField::new(0).get((center - (width+1)).with_z(base)) as i32 % 10;
            let old_y_offset = RandomField::new(0).get((center + (width+1)).with_z(base)) as i32 % 10;
            let old_super_center = Vec2::new(center.x - 3 + old_x_offset / 2, center.y - 3 + old_y_offset / 2);

            let x_offset = RandomField::new(0).get((center - length).with_z(base)) as i32 % 10;
            let y_offset = RandomField::new(0).get((center + length).with_z(base)) as i32 % 10;
            let super_center = Vec2::new(center.x - 3 + x_offset / 2, center.y - 3 + y_offset / 2);
            let room1_type = RandomField::new(0).get((center - length).with_z(base)) as i32 % 2;
            let room2_type = RandomField::new(0).get((center - length - 1).with_z(base)) as i32 % 2;
            // CliffTower Hoodoo Overlay

            let min_super_center = Vec2::<i32>::partial_min(old_super_center, super_center);
            let max_super_center = Vec2::<i32>::partial_max(old_super_center, super_center);
            let max_length = length.max(width);

            /*if s + 1 != storeys */{
                /*painter
                    .aabb(Aabb {
                        min: (min_super_center - max_length + 2).with_z(floor_level - height / 2),
                        max: (max_super_center + max_length + 1).with_z(floor_level + max_length.min(height / 2)),
                    }).as_kind()
                    .intersect*/(
                        painter.line_two_radius(
                            old_super_center.with_z(floor_level - height),
                            super_center.with_z(floor_level),
                            (width - 2) as f32,
                            (length - 1) as f32,
                            1.0,
                        )
                    )
                    .fill(brick, filler);
            }

            /* painter
                .cubic_bezier(
                    super_center.with_z(floor_level + (height / 2)),
                    (super_center - x_offset).with_z(floor_level + height),
                    (super_center - y_offset).with_z(floor_level + (height) + (height / 2)),
                    super_center.with_z(floor_level + (2 * height)),
                    (length - 1) as f32,
                )
                .fill(brick); */
            /* let diverge = ((x_offset * x_offset + y_offset * y_offset) as f32).sqrt(); */
            /* painter.aabb(Aabb {
                min: Vec2::new(super_center.x - length + 1, super_center.y - length + 1)
                    .with_z(floor_level + (height / 2)),
                max: Vec2::new(super_center.x + length - 1 - diverge as i32, super_center.y + length - 1 - diverge as i32)
                    .with_z(floor_level + (height) + (height / 4)),
            }).as_kind()
            .intersect(
                painter.superquadric/*_sheared*/(
                    Aabb {
                        min: super_center.with_z(floor_level + (height / 2)) +
                            Vec3::new(-length + 1, - length + 1, /*- length + 1*/- length + 1),
                        max: super_center.with_z(floor_level + (height) + (height / 4)) +
                            Vec3::new(-/*(x_offset + y_offset) / 2*/diverge as i32 + length, -/*(x_offset + y_offset) / 2*/diverge as i32 + length, /*length*/length),
                    },
                    /*Vec2::new(/*(*/-/*(x_offset + y_offset) / 2) as f32*/diverge / (((height) + (height / 4)) as f32), -/*(x_offset + y_offset) as f32*/diverge / (((height) + (height / 4)) as f32)),*/
                    2.01,
                )
            )
                .fill(brick);
            painter.aabb(Aabb {
                min: Vec2::new(super_center.x + length - 1 - diverge as i32, super_center.y + length - 1 - diverge as i32)
                    .with_z(floor_level + (height) + (height / 4)),
                max: Vec2::new(super_center.x - length + 1, super_center.y - length + 1)
                    .with_z(floor_level + (2 * height) - (height / 4)),
            }).as_kind()
            .intersect(
                painter.superquadric/*_sheared*/(
                    Aabb {
                        min: super_center.with_z(floor_level + (height)/* + (height / 4)*/) +
                            Vec3::new(-/*x_offset / 2*/diverge as i32 + length, -/*y_offset / 2*/diverge as i32 + length, /*length*/length),
                        max: super_center.with_z(floor_level + (2 * height) - (height / 4)) +
                            Vec3::new(-length + 1, - length + 1, /*- length + 1*/- length + 1),
                    },
                    /* Vec2::new(/*((x_offset + y_offset) / 2) as f32*/diverge / (((height) + (height / 2) - (height / 4)) as f32), /*((x_offset + y_offset) / 2) as f32*/diverge / (((height) + (height / 4)) as f32)), */
                    2.01,
                )
            )
                .fill(brick); */

            // only inhabit towers with enough storeys to have entries above ground
            if storeys > 3 {
                // wood or rocky platforms
                // only spawn on upper storeys
                if floor_level > base + 35 {
                    match RandomField::new(0).get((super_center - floor_level).with_z(base)) as i32
                        % 2
                    {
                        0 => {
                            painter
                                .superquadric(
                                    Aabb {
                                        min: (super_center - (5 * (length / 3)) + 2)
                                            .with_z(floor_level + 1),
                                        max: (super_center + (5 * (length / 3)) - 1)
                                            .with_z(floor_level + 5),
                                    },
                                    6.0,
                                )
                                .fill(wood, filler);
                                /*.without(*/
                                    painter.superquadric(
                                        Aabb {
                                            min: (super_center - (5 * (length / 3)) + 2)
                                                .with_z(floor_level + 3),
                                            max: (super_center + (5 * (length / 3)) - 2)
                                                .with_z(floor_level + 5),
                                        },
                                        6.0,
                                    )/*,
                                )
                                .fill(wood);*/
                                .clear(filler);
                            painter
                                .superquadric(
                                    Aabb {
                                        min: (super_center - (5 * (length / 3)) + 3)
                                            .with_z(floor_level),
                                        max: (super_center + (5 * (length / 3)) - 3)
                                            .with_z(floor_level + 2),
                                    },
                                    6.0,
                                )
                                .fill(wood, filler);
                            // lanterns & random sprites for wood platform corners
                            for dir in SQUARE_4 {
                                let corner_pos = super_center - (5 * (length / 4));
                                let sprite_pos = (corner_pos + (dir * (10 * (length / 4))))
                                    .with_z(floor_level + 4);
                                painter.sprite(
                                    sprite_pos,
                                    match (RandomField::new(0).get(sprite_pos)) % 10 {
                                        0 => SpriteKind::FireBowlGround,
                                        1 => SpriteKind::Bowl,
                                        3 => SpriteKind::VialEmpty,
                                        4 => SpriteKind::Crate,
                                        5 => SpriteKind::Pot,
                                        _ => SpriteKind::Lantern,
                                    },
                                    filler,
                                );
                            }
                            // planters for larger wood platforms
                            if length > 11 {
                                for r in 0..2 {
                                    for p in 0..((length / 2) - 2) {
                                        let planter_pos = Vec2::new(
                                            super_center.x - (2 * (length / 3))
                                                + (p * (length / 3)),
                                            super_center.y - ((4 * (length / 3)) + 2)
                                                + (r * ((8 * (length / 3)) + 4)),
                                        );
                                        painter
                                            .aabb(Aabb {
                                                min: Vec2::new(planter_pos.x - 1, planter_pos.y)
                                                    .with_z(floor_level + 4),
                                                max: Vec2::new(
                                                    planter_pos.x + 2,
                                                    planter_pos.y + 1,
                                                )
                                                .with_z(floor_level + 6),
                                            })
                                            .clear(filler);
                                        painter.rotated_sprite(
                                            planter_pos.with_z(floor_level + 4),
                                            SpriteKind::Planter,
                                            (4 - (r * 4)) as u8,
                                            filler,
                                        );
                                    }
                                }
                            }
                        },
                        _ => {
                            painter
                                .superquadric(
                                    Aabb {
                                        min: (center - length).with_z(floor_level + 1),
                                        max: (center + length).with_z(floor_level + 5),
                                    },
                                    sq_type,
                                )
                                .fill(brick, filler);
                                /*.without(*/
                                    painter.superquadric(
                                        Aabb {
                                            min: (center - length + 3).with_z(floor_level + 3),
                                            max: (center + length - 3).with_z(floor_level + 5),
                                        },
                                        sq_type,
                                    )/*,
                                )
                                .fill(brick)*/
                                .clear(filler);
                            painter
                                .superquadric(
                                    Aabb {
                                        min: (center - length + 1).with_z(floor_level),
                                        max: (center + length - 1).with_z(floor_level + 2),
                                    },
                                    sq_type,
                                )
                                .fill(brick, filler);
                        },
                    }
                }
                // room
                painter
                    .superquadric(
                        Aabb {
                            min: Vec2::new(super_center.x - length - 1, super_center.y - width - 1)
                                .with_z(floor_level),
                            max: Vec2::new(super_center.x + length + 1, super_center.y + width + 1)
                                .with_z(floor_level + height),
                        },
                        sq_type,
                    )
                    .fill(brick, filler);
                // clear room - leave some floor
                painter.aabb(Aabb {
                    min: Vec2::new(super_center.x - length + 1, super_center.y + 1 - width)
                        .with_z(floor_level + 4),
                    max: Vec2::new(super_center.x + length - 1, super_center.y - 1 + width)
                        .with_z(floor_level + height - 1),
                }).as_kind()
                .intersect(
                painter
                    .superquadric(
                        Aabb {
                            min: Vec2::new(
                                super_center.x - length + 1,
                                super_center.y + 1 - width,
                            )
                            .with_z(floor_level + 1),
                            max: Vec2::new(
                                super_center.x + length - 1,
                                super_center.y - 1 + width,
                            )
                            .with_z(floor_level + height - 1),
                        },
                        sq_type,
                    )
                    /* .clear(filler); */
                    /* .without(
                        painter.aabb(Aabb {
                            min: Vec2::new(super_center.x - length + 1, super_center.y + 1 - width)
                                .with_z(floor_level + 1),
                            max: Vec2::new(super_center.x + length - 1, super_center.y - 1 + width)
                                .with_z(floor_level + 4),
                        }).as_kind(),
                    ) */
                )
                    .clear(filler);
                // entries
                painter
                    .aabb(Aabb {
                        min: Vec2::new(super_center.x - length, super_center.y - 2)
                            .with_z(floor_level + 3),
                        max: Vec2::new(super_center.x - length + 6, super_center.y + 2)
                            .with_z(floor_level + 4),
                    })
                    .fill(brick, filler);
                painter
                    .aabb(Aabb {
                        min: Vec2::new(super_center.x + length - 6, super_center.y - 2)
                            .with_z(floor_level + 3),
                        max: Vec2::new(super_center.x + length, super_center.y + 2)
                            .with_z(floor_level + 4),
                    })
                    .fill(brick, filler);
                // colored sills
                painter
                    .aabb(Aabb {
                        min: Vec2::new(super_center.x - length - 1, super_center.y - 2)
                            .with_z(floor_level + 3),
                        max: Vec2::new(super_center.x - length, super_center.y + 2)
                            .with_z(floor_level + 4),
                    })
                    .fill(color, filler);
                painter
                    .aabb(Aabb {
                        min: Vec2::new(super_center.x + length, super_center.y - 2)
                            .with_z(floor_level + 3),
                        max: Vec2::new(super_center.x + length + 1, super_center.y + 2)
                            .with_z(floor_level + 4),
                    })
                    .fill(color, filler);
                if floor_level > base {
                    // clear entries
                    painter
                        .aabb(Aabb {
                            min: Vec2::new(super_center.x - length - 12, super_center.y - 2)
                                .with_z(floor_level + 4),
                            max: Vec2::new(super_center.x + length + 12, super_center.y + 2)
                                .with_z(floor_level + 7),
                        })
                        .clear(filler);
                    // door sprites
                    painter
                        .aabb(Aabb {
                            min: Vec2::new(super_center.x - length + 1, super_center.y - 2)
                                .with_z(floor_level + 4),
                            max: Vec2::new(super_center.x - length + 2, super_center.y + 2)
                                .with_z(floor_level + 7),
                        })
                        .without(
                            painter.aabb(Aabb {
                                min: Vec2::new(super_center.x - length + 1, super_center.y - 1)
                                    .with_z(floor_level + 4),
                                max: Vec2::new(super_center.x - length + 2, super_center.y + 1)
                                    .with_z(floor_level + 7),
                            }),
                        )
                        .fill(window, filler);
                        painter.aabb(Aabb {
                            min: Vec2::new(super_center.x + length - 1, super_center.y - 2)
                                .with_z(floor_level + 4),
                            max: Vec2::new(super_center.x + length, super_center.y + 2)
                                .with_z(floor_level + 7),
                        })
                        .without(
                            painter.aabb(Aabb {
                                min: Vec2::new(super_center.x + length - 1, super_center.y - 1)
                                    .with_z(floor_level + 4),
                                max: Vec2::new(super_center.x + length, super_center.y + 1)
                                    .with_z(floor_level + 7),
                            }),
                        )
                        .fill(window, filler);
                    // windows
                    painter
                        .aabb(Aabb {
                            min: Vec2::new(super_center.x - 4, super_center.y - width)
                                .with_z(floor_level + 5),
                            max: Vec2::new(super_center.x + 4, super_center.y - width + 3)
                                .with_z(floor_level + 6),
                        })
                        .fill(brick, filler);
                    painter
                        .aabb(Aabb {
                            min: Vec2::new(super_center.x - 4, super_center.y - width + 1)
                                .with_z(floor_level + 4),
                            max: Vec2::new(super_center.x + 4, super_center.y - width + 3)
                                .with_z(floor_level + 5),
                        })
                        .fill(brick, filler);
                    painter
                        .aabb(Aabb {
                            min: Vec2::new(super_center.x - 4, super_center.y + width - 3)
                                .with_z(floor_level + 5),
                            max: Vec2::new(super_center.x + 4, super_center.y + width + 1)
                                .with_z(floor_level + 6),
                        })
                        .fill(brick, filler);
                    painter
                        .aabb(Aabb {
                            min: Vec2::new(super_center.x - 4, super_center.y + width - 3)
                                .with_z(floor_level + 4),
                            max: Vec2::new(super_center.x + 4, super_center.y + width)
                                .with_z(floor_level + 5),
                        })
                        .fill(brick, filler);
                    painter
                        .aabb(Aabb {
                            min: Vec2::new(super_center.x - 3, super_center.y - width - 1)
                                .with_z(floor_level + 5),
                            max: Vec2::new(super_center.x + 3, super_center.y - width)
                                .with_z(floor_level + 6),
                        })
                        .fill(color, filler);
                    painter
                        .aabb(Aabb {
                            min: Vec2::new(super_center.x - 3, super_center.y + width + 1)
                                .with_z(floor_level + 5),
                            max: Vec2::new(super_center.x + 3, super_center.y + width + 2)
                                .with_z(floor_level + 6),
                        })
                        .fill(color, filler);
                    // clear windows
                    painter
                        .aabb(Aabb {
                            min: Vec2::new(super_center.x - 4, super_center.y - width - 12)
                                .with_z(floor_level + 6),
                            max: Vec2::new(super_center.x + 4, super_center.y + width + 12)
                                .with_z(floor_level + 9),
                        })
                        .clear(filler);
                    // window sprites
                    painter
                        .aabb(Aabb {
                            min: Vec2::new(super_center.x - 4, super_center.y - width + 1)
                                .with_z(floor_level + 6),
                            max: Vec2::new(super_center.x + 4, super_center.y - width + 2)
                                .with_z(floor_level + 9),
                        })
                        .without(
                            painter.aabb(Aabb {
                                min: Vec2::new(super_center.x - 1, super_center.y - width + 1)
                                    .with_z(floor_level + 6),
                                max: Vec2::new(super_center.x + 1, super_center.y - width + 2)
                                    .with_z(floor_level + 9),
                            }),
                        )
                        .fill(window2, filler);
                    painter
                        .aabb(Aabb {
                            min: Vec2::new(super_center.x - 4, super_center.y + width - 1)
                                .with_z(floor_level + 6),
                            max: Vec2::new(super_center.x + 4, super_center.y + width)
                                .with_z(floor_level + 9),
                        })
                        .without(
                            painter.aabb(Aabb {
                                min: Vec2::new(super_center.x - 1, super_center.y + width - 1)
                                    .with_z(floor_level + 6),
                                max: Vec2::new(super_center.x + 1, super_center.y + width)
                                    .with_z(floor_level + 9),
                            }),
                        )
                        .fill(window2, filler);
                }
                // room wall lamps
                for d in 0..2 {
                    let door_lamp_pos = Vec2::new(
                        super_center.x - length + 2 + (d * ((2 * length) - 4)),
                        super_center.y,
                    )
                    .with_z(floor_level + 9);
                    painter.rotated_sprite(
                        door_lamp_pos,
                        SpriteKind::WallLampSmall,
                        2 + ((d * 4) as u8),
                        filler,
                    );

                    let window_lamp_pos = Vec2::new(
                        super_center.x,
                        super_center.y - width + 2 + (d * ((2 * width) - 4)),
                    )
                    .with_z(floor_level + 9);
                    painter.rotated_sprite(
                        window_lamp_pos,
                        SpriteKind::WallLampSmall,
                        4 - ((d * 4) as u8),
                        filler,
                    );
                }
                // furniture sprites in room1(living_room, workshop), room2(kitchen, bath)
                // dont spawn sprites on stairways
                let stairway_clear_1 = Aabb {
                    min: (stair_pos1 - 5).with_z(floor_level + 3),
                    max: (stair_pos1 + 5).with_z(floor_level + 5),
                };
                let stairway_clear_2 = Aabb {
                    min: (stair_pos2 - 5).with_z(floor_level + 3),
                    max: (stair_pos2 + 5).with_z(floor_level + 5),
                };
                if length > width {
                    match room1_type {
                        0 => {
                            // living room
                            // distribute small sprites
                            let mut liv_sprites = vec![
                                SpriteKind::DrawerSmall,
                                SpriteKind::CoatRack,
                                SpriteKind::TableArabicSmall,
                                SpriteKind::CushionArabic,
                                SpriteKind::JugArabic,
                                SpriteKind::SpinningWheel,
                                SpriteKind::TanningRack,
                                SpriteKind::Loom,
                            ];
                            for dir in LOCALITY {
                                let pos = super_center + dir * (width / 3);
                                if !stairway_clear_1.contains_point(pos.with_z(floor_level + 4))
                                    && !stairway_clear_2.contains_point(pos.with_z(floor_level + 4))
                                    && !liv_sprites.is_empty()
                                {
                                    let sprite = liv_sprites.swap_remove(
                                        RandomField::new(0).get(pos.with_z(base)) as usize
                                            % liv_sprites.len(),
                                    );
                                    painter.sprite(pos.with_z(floor_level + 4), sprite, filler);
                                }
                            }
                            // bookshelfs
                            for d in 0..2 {
                                let pos = Vec2::new(
                                    super_center.x,
                                    super_center.y + width - 3 + (d * ((-2 * width) + 6)),
                                );
                                if !stairway_clear_1.contains_point(pos.with_z(floor_level + 4))
                                    && !stairway_clear_2.contains_point(pos.with_z(floor_level + 4))
                                {
                                    painter
                                        .aabb(Aabb {
                                            min: Vec2::new(pos.x - 2, pos.y - 2 + (2 * d))
                                                .with_z(floor_level + 4),
                                            max: Vec2::new(pos.x + 3, pos.y + 1 + (2 * d))
                                                .with_z(floor_level + 6),
                                        })
                                        .clear(filler);
                                    painter.rotated_sprite(
                                        pos.with_z(floor_level + 6),
                                        SpriteKind::BookshelfArabic,
                                        (4 * d) as u8,
                                        filler,
                                    );
                                }
                            }
                            // canapes
                            for d in 0..2 {
                                let pos = Vec2::new(
                                    super_center.x - length + 10 + (d * ((2 * length) - 20)),
                                    super_center.y - width + 4 + (d * ((2 * width) - 8)),
                                );
                                if !stairway_clear_1.contains_point(pos.with_z(floor_level + 4))
                                    && !stairway_clear_2.contains_point(pos.with_z(floor_level + 4))
                                {
                                    painter
                                        .aabb(Aabb {
                                            min: Vec2::new(
                                                pos.x - 1 - (3 * d),
                                                pos.y - 1 - (3 * d),
                                            )
                                            .with_z(floor_level + 4),
                                            max: Vec2::new(
                                                pos.x + 5 - (3 * d),
                                                pos.y + 5 - (3 * d),
                                            )
                                            .with_z(floor_level + 8),
                                        })
                                        .clear(filler);
                                    painter.rotated_sprite(
                                        pos.with_z(floor_level + 4),
                                        SpriteKind::CanapeArabic,
                                        (4 * d) as u8,
                                        filler,
                                    );
                                }
                            }
                            // decor set / separe / table large
                            for d in 0..2 {
                                let pos = Vec2::new(
                                    super_center.x - length + 8 + (d * ((2 * length) - 16)),
                                    super_center.y + width - 8 + (d * ((-2 * width) + 16)),
                                );
                                if !stairway_clear_1.contains_point(pos.with_z(floor_level + 4))
                                    && !stairway_clear_2.contains_point(pos.with_z(floor_level + 4))
                                {
                                    painter
                                        .aabb(Aabb {
                                            min: Vec2::new(pos.x - 2, pos.y - 1)
                                                .with_z(floor_level + 4),
                                            max: Vec2::new(pos.x + 3, pos.y + 2)
                                                .with_z(floor_level + 6),
                                        })
                                        .clear(filler);
                                    painter.sprite(
                                        pos.with_z(floor_level + 4),
                                        match (RandomField::new(0).get(pos.with_z(floor_level - d)))
                                            % 3
                                        {
                                            0 => SpriteKind::TableArabicLarge,
                                            1 => SpriteKind::DecorSetArabic,
                                            _ => SpriteKind::SepareArabic,
                                        },
                                        filler,
                                    )
                                };
                            }
                        },
                        _ => {
                            // workshop
                            for d in 0..2 {
                                // forge tools
                                let ft_pos = Vec2::new(
                                    super_center.x - 4 + (d * 6),
                                    super_center.y - width + 3 + (d * ((2 * width) - 6)),
                                );
                                if !stairway_clear_1.contains_point(ft_pos.with_z(floor_level + 4))
                                    && !stairway_clear_2
                                        .contains_point(ft_pos.with_z(floor_level + 4))
                                {
                                    painter
                                        .aabb(Aabb {
                                            min: Vec2::new(ft_pos.x - 2 + d, ft_pos.y - (3 * d))
                                                .with_z(floor_level + 4),
                                            max: Vec2::new(
                                                ft_pos.x + 2 + d,
                                                ft_pos.y + 4 - (3 * d),
                                            )
                                            .with_z(floor_level + 7),
                                        })
                                        .clear(filler);
                                    painter.rotated_sprite(
                                        ft_pos.with_z(floor_level + 4),
                                        SpriteKind::ForgeTools,
                                        (4 * d) as u8,
                                        filler,
                                    );
                                }
                                // hearth
                                let pos = Vec2::new(
                                    super_center.x + length - 12 + (d * ((-2 * length) + 24)),
                                    super_center.y - width + 3 + (d * ((2 * width) - 6)),
                                );
                                if !stairway_clear_1.contains_point(pos.with_z(floor_level + 4))
                                    && !stairway_clear_2.contains_point(pos.with_z(floor_level + 4))
                                {
                                    painter
                                        .aabb(Aabb {
                                            min: Vec2::new(pos.x - 2, pos.y - (4 * d))
                                                .with_z(floor_level + 4),
                                            max: Vec2::new(pos.x + 3, pos.y + 5 - (4 * d))
                                                .with_z(floor_level + 6),
                                        })
                                        .clear(filler);
                                    painter.rotated_sprite(
                                        pos.with_z(floor_level + 4),
                                        SpriteKind::Hearth,
                                        (4 * d) as u8,
                                        filler,
                                    );
                                }
                            }
                            // crafting stations
                            let mut ws_sprites = vec![
                                SpriteKind::CraftingBench,
                                SpriteKind::Forge,
                                SpriteKind::DismantlingBench,
                                SpriteKind::Anvil,
                            ];
                            for dir in LOCALITY {
                                let pos = super_center + dir * (width / 3);
                                if !stairway_clear_1.contains_point(pos.with_z(floor_level + 4))
                                    && !stairway_clear_2.contains_point(pos.with_z(floor_level + 4))
                                    && !ws_sprites.is_empty()
                                {
                                    let sprite = ws_sprites.swap_remove(
                                        RandomField::new(0).get(pos.with_z(base)) as usize
                                            % ws_sprites.len(),
                                    );
                                    painter.sprite(pos.with_z(floor_level + 4), sprite, filler);
                                }
                            }
                        },
                    }
                } else {
                    match room2_type {
                        0 => {
                            // bath
                            // wall tables with varying items
                            for d in 0..2 {
                                let pos = Vec2::new(
                                    super_center.x,
                                    super_center.y - width + 3 + (d * ((2 * width) - 7)),
                                );
                                if !stairway_clear_1.contains_point(pos.with_z(floor_level + 4))
                                    && !stairway_clear_2.contains_point(pos.with_z(floor_level + 4))
                                {
                                    painter
                                        .aabb(Aabb {
                                            min: Vec2::new(pos.x - 2, pos.y - (d * 3))
                                                .with_z(floor_level + 4),
                                            max: Vec2::new(pos.x + 3, pos.y + 4 - (d * 3))
                                                .with_z(floor_level + 7),
                                        })
                                        .clear(filler);
                                    painter.rotated_sprite(
                                        pos.with_z(floor_level + 4),
                                        SpriteKind::WallTableArabic,
                                        (4 * d) as u8,
                                        filler,
                                    );
                                    painter.rotated_sprite(
                                        pos.with_z(floor_level + 5),
                                        match (RandomField::new(0)
                                            .get((pos - d).with_z(floor_level)))
                                            % 4
                                        {
                                            0 => SpriteKind::Bowl,
                                            1 => SpriteKind::VialEmpty,
                                            2 => SpriteKind::JugArabic,
                                            _ => SpriteKind::JugAndBowlArabic,
                                        },
                                        (4 * d) as u8,
                                        filler,
                                    );
                                }
                            }
                            // distribute smaller sprites
                            let mut ba_sprites = vec![
                                SpriteKind::DrawerSmall,
                                SpriteKind::CoatRack,
                                SpriteKind::Crate,
                                SpriteKind::TableArabicSmall,
                                SpriteKind::SepareArabic,
                                SpriteKind::DecorSetArabic,
                            ];
                            for dir in LOCALITY {
                                let pos = super_center + dir * (width / 3);
                                if !stairway_clear_1.contains_point(pos.with_z(floor_level + 4))
                                    && !stairway_clear_2.contains_point(pos.with_z(floor_level + 4))
                                    && !ba_sprites.is_empty()
                                {
                                    let sprite = ba_sprites.swap_remove(
                                        RandomField::new(0).get(pos.with_z(base)) as usize
                                            % ba_sprites.len(),
                                    );
                                    painter.sprite(pos.with_z(floor_level + 4), sprite, filler)
                                }
                            }
                            // fountains
                            for d in 0..2 {
                                let pos = Vec2::new(
                                    super_center.x - length + 8 + (d * ((2 * length) - 16)),
                                    super_center.y + width - 8 + (d * ((-2 * width) + 16)),
                                );
                                if !stairway_clear_1.contains_point(pos.with_z(floor_level + 4))
                                    && !stairway_clear_2.contains_point(pos.with_z(floor_level + 4))
                                {
                                    painter
                                        .aabb(Aabb {
                                            min: (pos - 1).with_z(floor_level + 4),
                                            max: (pos + 2).with_z(floor_level + 5),
                                        })
                                        .clear(filler);
                                    painter.sprite(
                                        pos.with_z(floor_level + 4),
                                        SpriteKind::FountainArabic,
                                        filler,
                                    )
                                };
                            }
                        },
                        _ => {
                            // kitchen
                            // cupboards / ovens / cushions / jugs
                            for d in 0..2 {
                                let pos = Vec2::new(
                                    super_center.x + 3 - (d * 6),
                                    super_center.y - width + 3,
                                );
                                if !stairway_clear_1.contains_point(pos.with_z(floor_level + 4))
                                    && !stairway_clear_2.contains_point(pos.with_z(floor_level + 4))
                                {
                                    painter
                                        .aabb(Aabb {
                                            min: Vec2::new(pos.x - 1, pos.y)
                                                .with_z(floor_level + 4),
                                            max: Vec2::new(pos.x + 2, pos.y + 4)
                                                .with_z(floor_level + 7),
                                        })
                                        .clear(filler);
                                    painter.rotated_sprite(
                                        pos.with_z(floor_level + 4),
                                        match (RandomField::new(0).get(pos.with_z(floor_level))) % 2
                                        {
                                            0 => SpriteKind::CupboardArabic,
                                            _ => SpriteKind::OvenArabic,
                                        },
                                        4,
                                        filler,
                                    );
                                }
                            }
                            for d in 0..2 {
                                let pos = Vec2::new(
                                    super_center.x + 3 - (d * 6),
                                    super_center.y + width - 3,
                                );
                                if !stairway_clear_1.contains_point(pos.with_z(floor_level + 4))
                                    && !stairway_clear_2.contains_point(pos.with_z(floor_level + 4))
                                {
                                    painter
                                        .aabb(Aabb {
                                            min: Vec2::new(pos.x - 1, pos.y - 3)
                                                .with_z(floor_level + 4),
                                            max: Vec2::new(pos.x + 2, pos.y + 1)
                                                .with_z(floor_level + 7),
                                        })
                                        .clear(filler);
                                    painter.rotated_sprite(
                                        pos.with_z(floor_level + 4),
                                        match (RandomField::new(0).get(pos.with_z(floor_level))) % 4
                                        {
                                            0 => SpriteKind::CupboardArabic,
                                            1 => SpriteKind::OvenArabic,
                                            2 => SpriteKind::CushionArabic,
                                            _ => SpriteKind::JugArabic,
                                        },
                                        0,
                                        filler,
                                    );
                                }
                            }
                            // wall tables with varying items
                            for d in 0..2 {
                                let pos = Vec2::new(
                                    super_center.x,
                                    super_center.y - width + 3 + (d * ((2 * width) - 6)),
                                );
                                if !stairway_clear_1.contains_point(pos.with_z(floor_level + 4))
                                    && !stairway_clear_2.contains_point(pos.with_z(floor_level + 4))
                                {
                                    painter
                                        .aabb(Aabb {
                                            min: Vec2::new(pos.x - 2, pos.y - (3 * d))
                                                .with_z(floor_level + 4),
                                            max: Vec2::new(pos.x + 2, pos.y + 4 - (3 * d))
                                                .with_z(floor_level + 7),
                                        })
                                        .clear(filler);
                                    painter.rotated_sprite(
                                        pos.with_z(floor_level + 4),
                                        SpriteKind::WallTableArabic,
                                        (4 * d) as u8,
                                        filler,
                                    );
                                    painter.rotated_sprite(
                                        pos.with_z(floor_level + 5),
                                        match (RandomField::new(0).get(pos.with_z(floor_level))) % 5
                                        {
                                            0 => SpriteKind::MelonCut,
                                            1 => SpriteKind::JugAndBowlArabic,
                                            2 => SpriteKind::Bowl,
                                            3 => SpriteKind::JugArabic,
                                            _ => SpriteKind::VialEmpty,
                                        },
                                        (4 * d) as u8,
                                        filler,
                                    );
                                }
                            }
                            // distribute small sprites
                            let mut kit_sprites = vec![
                                SpriteKind::DrawerSmall,
                                SpriteKind::Crate,
                                SpriteKind::VialEmpty,
                                SpriteKind::Bowl,
                                SpriteKind::TableArabicSmall,
                                SpriteKind::JugArabic,
                                SpriteKind::CookingPot,
                                SpriteKind::Cauldron,
                            ];
                            for dir in LOCALITY {
                                let pos = super_center + dir * (width / 3);
                                if !stairway_clear_1.contains_point(pos.with_z(floor_level + 4))
                                    && !stairway_clear_2.contains_point(pos.with_z(floor_level + 4))
                                    && !kit_sprites.is_empty()
                                {
                                    let sprite = kit_sprites.swap_remove(
                                        RandomField::new(0).get(pos.with_z(base)) as usize
                                            % kit_sprites.len(),
                                    );
                                    painter.sprite(pos.with_z(floor_level + 4), sprite, filler);
                                }
                            }
                        },
                    }
                };
                // stairways starting from 2nd storey
                if s > 0 {
                    //clear stairway
                    painter
                        .cylinder(Aabb {
                            min: (stair_pos1 - 3).with_z(floor_level - height + 4),
                            max: (stair_pos1 + 3).with_z(floor_level + 7),
                        })
                        .clear(filler);
                    //stairway
                    let stair_radius1 = 4.0;
                    let stairs_clear1 = painter.cylinder(Aabb {
                        min: (stair_pos1 - stair_radius1 as i32).with_z(floor_level - height),
                        max: (stair_pos1 + stair_radius1 as i32).with_z(floor_level + 4),
                    });
                    let stairs_fill = 
                        /* painter.arena.alloc_with(move || */|pos| crate::site2::plot::dungeon::spiral_staircase(
                                stair_pos1.with_z(floor_level + 4),
                                stair_radius1,
                                0.5,
                                7.0,
                            )(pos).then(|| brick_fill(pos)).flatten()/*)*/;
                    stairs_clear1
                        .fill(/*Fill::Sampling*/filler.sampling(&stairs_fill), filler);
                }
                // spawn mountaineers in each room
                let spawn_pos = super_center.with_z(floor_level + 4);
                let npc_amount = RandomField::new(0).get(spawn_pos) % 4;
                for _ in 0..npc_amount {
                    let mut rng = rand::thread_rng();
                    filler.spawn(
                        EntityInfo::at(spawn_pos.map(|e| e as f32))
                            .with_asset_expect("common.entity.village.mountaineer", &mut rng),
                    );
                }
            }
            // vary next storey
            length += -1;
            width += -1;
            height += -1;
            floor_level += height;
            mem::swap(&mut length, &mut width);
            mem::swap(&mut stair_pos1, &mut stair_pos2);
        }
    }
}
